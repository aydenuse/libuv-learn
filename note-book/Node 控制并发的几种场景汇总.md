为什么要考你并发控制？

#### 0. 背景

前不久看很多帖子、微信群分享面经，很多大厂面试总会遇到这类问题：

> "完成以下功能：最大并发数为 n，保证每次最多只有 n 个任务并发执行"
> "请实现一个并发控制器"
> ……

当时草草写出来就没在意了，最近年底不是很忙，想好好总结一下，相信我：看到最后的人运气都不会太差。

抛开面试先不管，实际业务场景中，我们经常会遇到这样的问题：

* 无论前后端，多文件上传，大家总会想批量传输来提高效率，大文件的话会考虑分片批量上传，这个过程中需要注意控制并发，以防止浏览器或者服务器卡死
* 后端查 `DB` ，`Mongo` 最为典型，三张表一起查，`Promise.all()`，如果是晚上跑 `100w` 条数据的定时任务呢？，嗯对：`Promise.map()` 控制并发
* 心爱的女孩有很多工作数据需要下载，该网站不支持批量打包下载，只能一个一个点击下载，问你会不会爬虫，能不能爬（说起来很简单）下来？要面子的你说当然可以；嗯，你就开始学习爬虫，爬虫的过程中你发现数据量好大，或者发现自己的程序不够优雅，总是爬一点点就报错，中断，过一会，重启，又好了。聪明的你又想到了控制并发！后来，你们顺理成章的 ……

你看，控制并发能帮你解决多少事啊！

吹完水，进入正题：接下来一步一步实现这个控制并发的功能，我会尽可能详细的描述我的思路 ~

#### 1. 骨架：

![carbon (3)](C:\Users\42977\Desktop\carbon (3).png)

这个骨架相信大家都能写出来，也不难理解：既然是控制并发，那这几个参数必不可少：

`pool`：任务池，存放所有的任务，待处理

`working`：当前正在运行的任务数量

`concurrency`：并发阀值

还包括两个函数， 如代码所示：`run` 负责从中任务池中提取任务，并执行；`add` 向任务池中添加任务。

#### 2. 基本逻辑

* 什么时候执行呢？我希望的当然是 "懒执行"，只有添加任务的时候才会执行，那么首先得把 `添加任务` 和 `执行任务` 串联起来：

```diff
    add(job) {
      this.pool.push(job);
+     this.run();
    }
```

到这里，就已经做到了：来一个任务执行一个，来一个任务执行一个，来一个任务执行一个 ……

* 就这？？嗯，先别急，来加点标志：

```diff
    ……
    constructor(concurrency) {
      this.pool = [];
+     this.done = 0;
      this.working = 0;
      this.concurrency = concurrency;
    }

    async run() {
+     if (this.pool.length) {
         const job = this.pool.shift(); // 任务池中取一个任务
+        this.working++;
         await job(); // 执行完成一个任务
+        this.done++;
+        this.working--;
+        this.printf();
+     }
    }
    
+   printf() {
+     console.log(`当前任务池:${this.pool.length}, 最大并发数:${this.concurrency}, 运行中:${this.working}, 已完成:${this.done}`);
+   }
+ }  

+ // mock 请求
+ const reqMock = () => new Promise(res =>
+   setTimeout(() => res(), Math.random().toFixed(3) * 3000, res))

+ // 以下方式二选一
+ // 添加任务方式 1
+ for (let i = 0; i < 100; i++) {
+   concurrentExecutor.add(reqMock);
+ }

+ // 添加任务方式 2
+ setInterval(() => {
+     concurrentExecutor.add(reqMock);
+ }, 200)
```

从任务池取一个任务：正在运行的任务 +1；

执行完一个任务：正在运行的任务 -1，已完成的任务 +1；

再加点日志，方便查看；

添加 `reqMock` 函数（方式1）模拟异步任务，日志如下：

```
当前任务池:0, 最大并发数:5, 运行中:100, 已完成:0
当前任务池:0, 最大并发数:5, 运行中:99, 已完成:1
…………
…………
当前任务池:0, 最大并发数:5, 运行中:2, 已完成:98
当前任务池:0, 最大并发数:5, 运行中:1, 已完成:99
```

* 既然是控制并发，很重要的一个逻辑就是：**当正在运行的任务数 (working) 等于阈值 (concurrency)，就不可以再有新的任务执行。**上面的日志也看到了，第一条运行中的任务就达到了 100 个。

接下来实现这段逻辑，做个限制（其实就是个判断）：

```diff
    async run() {
+     if (this.working === this.concurrency) {
+       return;
+     }
      if (this.pool.length) {
        const job = this.pool.shift();
        this.working++;
        await job();
        this.done++;
        this.working--;
        this.printf();
      }
    }
```

执行一下？日志如下：

```
当前任务池:95, 最大并发数:5, 运行中:4, 已完成:1
当前任务池:95, 最大并发数:5, 运行中:3, 已完成:2
当前任务池:95, 最大并发数:5, 运行中:2, 已完成:3
当前任务池:95, 最大并发数:5, 运行中:1, 已完成:4
当前任务池:95, 最大并发数:5, 运行中:0, 已完成:5
```

执行完 5 个任务就停止了，并不是我们理想的，这是为什么呢？

> 因为我们加了上面判断这个逻辑，一旦运行中的任务达到五个，就直接在改逻辑处返回了，而没有继续执行下面的代码，这样也就导致 "运行中的任务" 标志没有被释放，也就是没有 `working--`。

 所以上面的逻辑其实还少了一部分，补全如下：（这个很关键）

> 当正在运行的任务数 (working) 等于阈值 (concurrency)，就不可以再有新的任务执行，直到有执行中的任务执行完毕。 

显然在 "执行中的任务" 执行完毕后，没有从任务池取出任务继续执行，那么执行完毕后，我们该怎么通知执行器继续执行呢？

#### 3. 核心逻辑

最关键的一步："执行中的任务" 执行完毕后，从任务池中取出任务，继续执行。你品，你细品，是不是就是骨架图中一开始定义的 `run` 函数？嗯，是的！整理一下代码：

```diff
	'use strict'
+   const EventEmitter = require('events')
    class ConcurrentExecutor {
        constructor(concurrency) {
            this.done = 0;
            this.pool = [];
            this.working = 0;
            this.concurrency = concurrency;
+           this.event = new EventEmitter();
+           this.event.on('done', () => {
+               this.done++;
+               this.working--;
+               this.run()
+               this.printf();
+           })
        }

        async run() {
            if (this.working === this.concurrency) {
                return;
            }
            if (this.pool.length) {
                const job = this.pool.shift();
                this.working++;
                await job();
+               this.event.emit('done');
            }
        }
    }
```

我这里使用的是事件通知的方式，同样的也可以用回调函数，只不过回调需要在业务代码中执行。

初始化的时候定义 `一个任务完成时` 的事件监听，一个任务完成时触发：

1. 打印日志（方便观察）
2. 任务完成数量 +1
3. 正在执行的任务数量 -1
4. 从任务池中取出任务并执行。

测试一下，日志如下：

```
当前任务池:94, 最大并发数:5, 运行中:5, 已完成:1
当前任务池:93, 最大并发数:5, 运行中:5, 已完成:2
当前任务池:92, 最大并发数:5, 运行中:5, 已完成:3
当前任务池:91, 最大并发数:5, 运行中:5, 已完成:4
……
当前任务池:1, 最大并发数:5, 运行中:5, 已完成:94
当前任务池:0, 最大并发数:5, 运行中:5, 已完成:95
……
当前任务池:0, 最大并发数:5, 运行中:2, 已完成:98
当前任务池:0, 最大并发数:5, 运行中:1, 已完成:99
当前任务池:0, 最大并发数:5, 运行中:0, 已完成:100
```

至此，控制并发功能已经实现！

#### 4. 总结

逻辑其实没多少，就是这样：

> 当正在运行的任务数 (working) 等于阈值 (concurrency)，就不可以再有新的任务执行，直到有执行中的任务执行完毕。 

那么，这个 "执行中的任务执行完毕" 的时刻就需要某种机制去主动触发 "从任务池中拿任务" 的动作，这种机制有 **两种实现**：

1. 事件通知（上面用到的），
2. 任务函数 `job` 参数中传一个回调函数，等该任务执行完毕后执行回调，回调内部也是调用 `run` 函数为了触发 " 从任务池中拿任务" 的动作（留个作业：有兴趣的同学可以试试）。

控制这个功能实现起来并不算难，如果想自己造轮子并投入使用，还是有一些细节需要结合实际的使用去考虑，看了一下 `Promise.map()` 的源码，核心内容没多少，大部分都是异常情况的判断和处理，毕竟作为一个公共库，得覆盖各种非常规的操作。
#### 5. 扩展

这个小玩意看似简单，其实还有很多可以补充和扩展的地方，比如：

1. 监听所有任务完成，添加返回值，参考 `bluebird` 中  `Promise.map()` 的返回
2. 错误重试，任务失败，可以把任务重新放进任务池
3. 写成一个服务，多节点向任务池中添加任务，做成一个类似 `RabbitMQ` 的队列组件
4. 单机多节点的 `RabbitMQ` ，`Redis` 可以做任务池
5. 多机多节点 …… 有点复杂了
6. ……

大家有别的想法欢迎罗列 ~



> 源码地址：




