'use strict';

/**
 * 
 * 背景：
 * 
 * 一、二叉查找树（二叉搜索树）：就是一颗二叉树，他的左节点比父节点要小，右节点比父节点要大，高度决定了查询效率。最差的情况是退化成一个链表
 * 1. 查找
 * 2. 插入
 * 3. 遍历
 *    3.1. 前序遍历：左根右
 *    3.2. 中序遍历：根左右
 *    3.3. 后序遍历：左右根
 * 4. 查找最小值（红黑树通用）：沿着根节点的左子树一路查找，直到最后一个不为空的节点，该节点就是当前这个树的最小节点
 * 5. 查找最小值（红黑树通用）：沿着根节点的右子树一路查找，直到最后一个不为空的节点，该节点就是当前这个树的最大节点
 * 6. 前驱节点：小于当前节点的最大值
 * 7. 后继节点：大于当前节点的最小值
 * 8. 删除：本质上是找前驱节点或者后继节点替代
 *    8.1. 叶子节点可以直接删除
 *    8.2. 只有一个子节点的用子节点替代
 *    8.3. 有两个子节点的，需要找到替代节点（替代节点就是前驱节点或者后继节点）
 * 缺点：插入的时候树会倾斜，最差就是个链表
 * 
 * 
 * 二、AVL 树
 * 基于 BST 存在的问题，平衡因子不大于一
 * 
 * 缺点：平衡条件太苛刻，为满足平衡因子条件，插入都要调整树的高度
 * 
 * 
 * 三、2-3-4 树
 * 2-3-4 树是四阶的 B 树，他属于一种多路查找树，它的结构有以下限制：
 * 1. 所有的子节点都拥有相同的深度
 * 2. 节点之能事 2-节点，3-节点，4-节点之一（有几个孩子就叫几节点）
 *    2.1 2-节点：包含 1 个元素的节点，有 2 个子节点
 *    2.2 3-节点：包含 2 个元素的节点，有 3 个子节点
 *    2.3 4-节点：包含 3 个元素的节点，有 4 个子节点
 *    2.4 所有的节必须至少包含 1 个元素
 * 3. 元素始终保持排序，整体上保持二叉查找树的性质，即父节点大于左子节点，小于右子节点；而且节点有多个元素时，每个元素必须大于它左边的和它左子树中的元素
 * 
 * TODO: 结论（回头来看）：一个 2-3-4 树对应多个红黑树，一个红黑树只能对应一个 2-3-4 树
 * 
 * 
 * 
 * 
 * https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
 * 
 * 本质上是对二叉树的节点进行染色，从而达到一种平衡（黑色平衡）
 * 
 * 1. 每个节点要么是黑色，要么是红色
 * 2. 根节点是黑色
 * 3. 每个叶子节点是黑色
 * 4. 每个红色节点的两个子节点一定是黑色
 * 5. 任意一节点到每个叶子节点的路径都包含数量相同的黑节点
 * 
 * 
 * 
 */
